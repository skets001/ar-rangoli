<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"
  />
  <title>AR Rangoli — Interactive</title>
  <meta name="theme-color" content="#0c0c0c" />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
  <style>
    :root {
      --bg: #0b0b0e;
      --fg: #f7f2ea;
      --accent: #e15a97;
      --accent-2: #ffb703;
      --muted: #8b8b93;
    }
    html, body { margin: 0; padding: 0; height: 100%; background: var(--bg); color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", "Helvetica Neue", Arial;
    }
    canvas { display: block; }

    /* UI */
    .overlay{position:fixed;inset:0;pointer-events:none;display:grid;place-items:end center;padding:env(safe-area-inset-bottom)}
    .hud{width:100%;box-sizing:border-box;padding:14px 16px 18px;display:flex;gap:10px;justify-content:center;align-items:center;background:linear-gradient(180deg,rgba(0,0,0,0) 0%, rgba(12,12,14,0.85) 30%, rgba(12,12,14,1) 100%);pointer-events:none}
    .pill{pointer-events:auto;border:1px solid #262630;background:#13131a;color:var(--fg);border-radius:999px;padding:10px 14px;font-size:14px;opacity:.95;display:inline-flex;align-items:center;gap:8px;box-shadow:0 2px 10px rgba(0,0,0,.35)}
    .pill b{color:var(--accent-2)}
    .topbar{position:fixed;top:0;left:0;right:0;display:flex;justify-content:space-between;align-items:center;padding:12px 14px;gap:10px;background:linear-gradient(180deg,rgba(12,12,14,.95) 0%, rgba(12,12,14,.4) 100%);backdrop-filter:blur(6px);z-index:3;pointer-events:none}
    .brand{pointer-events:auto;font-weight:700;letter-spacing:.3px;color:var(--fg);font-size:15px;display:inline-flex;align-items:center;gap:10px}
    .brand .dot{width:10px;height:10px;border-radius:50%;background:radial-gradient(circle at 30% 30%, #fff 0, #ffd166 40%, #f94144 100%);box-shadow:0 0 8px rgba(255,210,50,.9)}
    .badge{pointer-events:auto;border-radius:999px;border:1px solid #2c2c34;padding:6px 10px;font-size:12px;color:var(--muted)}
    .center-cue{position:fixed;inset:0;display:grid;place-items:center;z-index:2;pointer-events:none;transition:opacity .3s ease}
    .center-cue .card{pointer-events:auto;background:rgba(10,10,14,.75);backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,.06);border-radius:16px;padding:16px 18px;text-align:center;max-width:280px;color:var(--fg);box-shadow:0 10px 30px rgba(0,0,0,.35);animation:pop .38s ease-out both}
    @keyframes pop{from{transform:translateY(8px) scale(.98);opacity:0}to{transform:translateY(0) scale(1);opacity:1}}
    .center-cue h3{margin:0 0 6px;font-size:18px}
    .center-cue p{margin:0;font-size:13px;color:var(--muted)}
    .loader{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(circle at 50% 40%, #141420, #0b0b0e 60%);z-index:4;color:var(--fg);text-align:center;padding:24px}
    .chakra{width:84px;height:84px;border-radius:50%;border:3px dashed #ffd166;animation:spin 2.2s linear infinite;box-shadow:0 0 0 2px rgba(255,255,255,.03) inset;position:relative;margin:auto}
    .chakra::after{content:"";position:absolute;inset:14px;border-radius:50%;border:2px dotted #e15a97;animation:spin 3.6s linear infinite reverse;filter:drop-shadow(0 0 12px rgba(225,90,151,.35))}
    @keyframes spin{to{transform:rotate(360deg)}}
    .loader p{margin-top:16px;font-size:14px;color:var(--muted)}
    .btn{pointer-events:auto;display:inline-block;margin-top:14px;padding:12px 16px;border-radius:12px;border:1px solid #34343d;background:#17171f;color:#fff;font-weight:600;cursor:pointer}
    .btn:active{transform:scale(.98)}
    .hint{margin-top:10px;font-size:12px;color:#9b9ba3}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  </style>
</head>
<body>
  <!-- Top bar -->
  <div class="topbar" id="topbar">
    <div class="brand"><span class="dot"></span> AR Rangoli</div>
    <div class="badge" id="statusBadge">Ready</div>
  </div>

  <!-- Loader (now doubles as "Enter AR" gate) -->
  <div class="loader" id="loader" role="status" aria-live="polite">
    <div class="chakra" aria-hidden="true"></div>
    <p id="loaderText">Tap to start AR (needed for permission)</p>
    <button class="btn" id="enterBtn">Enter AR</button>
    <div class="hint">
      If you previously denied camera: Chrome ⋮ → Site settings → Reset permissions.
      <br/>Must be HTTPS + Android Chrome with ARCore.
    </div>
  </div>

  <!-- Center cue -->
  <div class="center-cue" id="centerCue">
    <div class="card">
      <h3>Move your phone</h3>
      <p>Look around to detect a floor/wall. <b>Tap</b> to place the rangoli.</p>
    </div>
  </div>

  <!-- HUD -->
  <div class="overlay">
    <div class="hud">
      <div class="pill">Move closer to rangolis to see them glow ✨ Tap to add more!</div>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>

  <script>
    function createReticle() {
      const geo = new THREE.RingGeometry(0.09, 0.1, 64);
      geo.rotateX(-Math.PI / 2);
      const mat = new THREE.MeshBasicMaterial({ color: 0xffb703, transparent: true, opacity: 0.95 });
      const ring = new THREE.Mesh(geo, mat);
      const geo2 = new THREE.RingGeometry(0.055, 0.07, 32);
      geo2.rotateX(-Math.PI / 2);
      const mat2 = new THREE.MeshBasicMaterial({ color: 0xe15a97, transparent: true, opacity: 0.95 });
      const ring2 = new THREE.Mesh(geo2, mat2);
      const group = new THREE.Group(); group.add(ring, ring2);
      group.tick = (t) => { const s = 1 + Math.sin(t * 2.2) * 0.03; group.scale.set(s, s, s); };
      group.visible = false; return group;
    }

    function drawRangoliTexture(size = 1024) {
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d'); ctx.clearRect(0,0,size,size);
      const cx = size/2, cy = size/2, R = size*0.46;
      function petal(angle, r1, r2, w, colorA, colorB){
        ctx.save(); ctx.translate(cx,cy); ctx.rotate(angle);
        const grad = ctx.createLinearGradient(0,-r1,0,-r2);
        grad.addColorStop(0,colorA); grad.addColorStop(1,colorB);
        ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(0,-r1);
        ctx.bezierCurveTo(w,-r1*0.65, w,-r2*0.35, 0,-r2);
        ctx.bezierCurveTo(-w,-r2*0.35, -w,-r1*0.65, 0,-r1);
        ctx.closePath(); ctx.fill(); ctx.restore();
      }
      const radial = ctx.createRadialGradient(cx,cy,R*.05,cx,cy,R*1.02);
      radial.addColorStop(0,'rgba(255,255,255,0.06)');
      radial.addColorStop(0.65,'rgba(255,210,100,0.04)');
      radial.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle = radial; ctx.beginPath(); ctx.arc(cx,cy,R*1.05,0,Math.PI*2); ctx.fill();
      const petals = 12;
      for(let i=0;i<petals;i++){ const a=(i/petals)*Math.PI*2; petal(a, R*.92, R*.55, R*.25, '#ff6b6b', '#f94144'); }
      for(let i=0;i<petals;i++){ const a=(i/petals)*Math.PI*2+Math.PI/petals; petal(a, R*.6, R*.34, R*.16, '#ffd166', '#ffb703'); }
      for(let i=0;i<petals;i++){ const a=(i/petals)*Math.PI*2; petal(a, R*.36, R*.15, R*.11, '#7bd389', '#06d6a0'); }
      ctx.strokeStyle='rgba(255,255,255,0.82)'; ctx.lineWidth=size*0.006;
      [0.52,0.38,0.26,0.18,0.12].forEach(mult=>{ctx.beginPath();ctx.arc(cx,cy,R*mult,0,Math.PI*2);ctx.stroke();});
      function dottedCircle(r,dots,color){
        for(let i=0;i<dots;i++){const a=(i/dots)*Math.PI*2; const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r;
          const g=ctx.createRadialGradient(x,y,0,x,y,size*0.02);
          g.addColorStop(0,color); g.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=g;
          ctx.beginPath(); ctx.arc(x,y,size*0.012,0,Math.PI*2); ctx.fill();
        }
      }
      dottedCircle(R*0.48,36,'#ffb703'); dottedCircle(R*0.33,24,'#e15a97'); dottedCircle(R*0.22,16,'#90e0ef');
      const g2 = ctx.createRadialGradient(cx,cy,0,cx,cy,R*0.16);
      g2.addColorStop(0,'#fff'); g2.addColorStop(0.4,'#ffd166'); g2.addColorStop(1,'#e15a97');
      ctx.fillStyle=g2; ctx.beginPath(); ctx.arc(cx,cy,R*0.16,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#2d0e36'; ctx.beginPath(); ctx.arc(cx,cy,R*0.04,0,Math.PI*2); ctx.fill();
      return c;
    }

    // Optimized particle system - fewer particles, smarter updates
    function createFlowingParticles() {
      const particleCount = 30; // Reduced from 80
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      
      const diwaliColors = [
        new THREE.Color(0xffd166),
        new THREE.Color(0xe15a97),
        new THREE.Color(0xff6b6b)
      ];

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 2;
        positions[i3] = Math.cos(angle) * radius;
        positions[i3 + 1] = Math.random() * 0.2;
        positions[i3 + 2] = Math.sin(angle) * radius;
        
        const color = diwaliColors[Math.floor(Math.random() * diwaliColors.length)];
        colors[i3] = color.r;
        colors[i3 + 1] = color.g;
        colors[i3 + 2] = color.b;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      const particles = new THREE.Points(geometry, material);
      particles.userData.speeds = [];
      particles.userData.phases = [];
      
      for (let i = 0; i < particleCount; i++) {
        particles.userData.speeds.push(Math.random() * 0.2 + 0.15);
        particles.userData.phases.push(Math.random() * Math.PI * 2);
      }

      return particles;
    }

    // Interactive ripple effect when user gets close
    function createRippleEffect() {
      const geo = new THREE.RingGeometry(0.1, 0.12, 32);
      geo.rotateX(-Math.PI / 2);
      const mat = new THREE.MeshBasicMaterial({ 
        color: 0xffd166, 
        transparent: true, 
        opacity: 0,
        side: THREE.DoubleSide
      });
      const ripple = new THREE.Mesh(geo, mat);
      ripple.visible = false;
      return ripple;
    }

    (function setup() {
      const loader = document.getElementById('loader');
      const loaderText = document.getElementById('loaderText');
      const enterBtn = document.getElementById('enterBtn');
      const centerCue = document.getElementById('centerCue');
      const statusBadge = document.getElementById('statusBadge');

      // Pre-checks
      if (!('xr' in navigator)) {
        loaderText.innerHTML = "WebXR not available. Use <b>Android Chrome</b> over HTTPS.";
        enterBtn.style.display = "none";
        return;
      }

      // Require a user gesture to start AR
      enterBtn.addEventListener('click', async () => {
        enterBtn.disabled = true;
        loaderText.textContent = "Starting AR…";
        try {
          const supportsAR = await navigator.xr.isSessionSupported('immersive-ar').catch(() => false);
          if (!supportsAR) {
            loaderText.innerHTML = "Your device/browser doesn't support WebXR AR. Try Android Chrome.";
            return;
          }
          await startAR();
        } catch (err) {
          loaderText.innerHTML = "Camera permission denied or AR failed.<br/><small>" + String(err && err.message || err) + "</small>";
          enterBtn.disabled = false;
        }
      });

      async function startAR() {
        // THREE scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera();
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
        const reticle = createReticle(); 
        scene.add(reticle);

        statusBadge.textContent = "Drawing rangoli…";
        const rangoliCanvas = drawRangoliTexture(1024);
        const rangoliTex = new THREE.CanvasTexture(rangoliCanvas);
        rangoliTex.anisotropy = 8;

        const rangoliMaterial = new THREE.MeshBasicMaterial({ map: rangoliTex, transparent: true, opacity: 1 });

        function createRangoliMesh() {
          const sizeMeters = 0.8;
          const geo = new THREE.PlaneGeometry(sizeMeters, sizeMeters);
          const mesh = new THREE.Mesh(geo, rangoliMaterial.clone());
          mesh.rotation.x = -Math.PI / 2;
          mesh.renderOrder = 1;
          
          const shadow = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.18 }));
          shadow.position.y = -0.001; 
          shadow.scale.set(1.04,1.04,1.04); 
          mesh.add(shadow);
          
          mesh.scale.set(0.6,0.6,0.6); 
          mesh.userData.spawnT = performance.now(); 
          mesh.userData.animIn = true;
          mesh.userData.lastProximityCheck = 0;
          mesh.userData.glowIntensity = 0;
          
          // Add optimized particles
          const particles = createFlowingParticles();
          particles.position.y = 0.05;
          mesh.add(particles);
          mesh.userData.particles = particles;
          
          // Add interactive ripple
          const ripple = createRippleEffect();
          mesh.add(ripple);
          mesh.userData.ripple = ripple;
          
          return mesh;
        }

        const sessionInit = {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['light-estimation']
        };

        const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
        statusBadge.textContent = "Point phone to scan…";

        renderer.xr.setReferenceSpaceType('local');
        await renderer.xr.setSession(session);

        const referenceSpace = await session.requestReferenceSpace('local');
        const viewerSpace = await session.requestReferenceSpace('viewer');
        const hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

        const placedObjects = [];
        session.addEventListener('select', () => {
          if (!reticle.visible) return;
          const mesh = createRangoliMesh();
          mesh.position.setFromMatrixPosition(reticle.matrix);
          const rot = new THREE.Quaternion().setFromRotationMatrix(reticle.matrix);
          mesh.quaternion.copy(rot);
          const up = new THREE.Vector3(0,1,0).applyQuaternion(mesh.quaternion);
          if (Math.abs(up.y) < 0.4) {
            const normal = new THREE.Vector3(0,0,-1).applyQuaternion(rot).normalize();
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), normal);
            mesh.quaternion.copy(targetQuat);
            mesh.position.addScaledVector(normal, 0.002);
          } else {
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.y += 0.001;
          }
          scene.add(mesh); 
          placedObjects.push(mesh);
          centerCue.style.opacity = "0"; 
          setTimeout(()=>centerCue.style.display="none", 400);
        });

        loader.style.opacity = "0"; 
        setTimeout(()=>loader.remove(), 200);

        renderer.setAnimationLoop((t, frame) => {
          if (reticle.tick) reticle.tick(t/1000);
          if (frame) {
            const hits = frame.getHitTestResults(hitTestSource);
            if (hits.length) {
              const pose = hits[0].getPose(referenceSpace);
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            } else {
              reticle.visible = false;
            }
          }
          
          const now = performance.now();
          const time = t / 1000;
          
          // Get camera position for proximity detection
          const cameraPos = new THREE.Vector3();
          camera.getWorldPosition(cameraPos);
          
          for (const obj of placedObjects) {
            // Scale-in animation
            if (obj.userData.animIn) {
              const dt = Math.min((now - obj.userData.spawnT) / 450, 1);
              const s = 0.6 + (1 - 0.6) * (1 - Math.pow(1 - dt, 3));
              obj.scale.set(s,s,s);
              if (dt >= 1) obj.userData.animIn = false;
            }
            
            // Proximity-based interaction (check every 100ms)
            if (now - obj.userData.lastProximityCheck > 100) {
              obj.userData.lastProximityCheck = now;
              const objPos = new THREE.Vector3();
              obj.getWorldPosition(objPos);
              const distance = cameraPos.distanceTo(objPos);
              
              // Interactive glow when user is close (within 1.5 meters)
              if (distance < 1.5) {
                const proximity = 1 - (distance / 1.5);
                obj.userData.glowIntensity = Math.min(obj.userData.glowIntensity + 0.05, proximity * 0.8);
                
                // Trigger ripple effect
                if (obj.userData.ripple && proximity > 0.5) {
                  obj.userData.ripple.visible = true;
                  obj.userData.ripple.userData.rippleStart = now;
                }
              } else {
                obj.userData.glowIntensity = Math.max(obj.userData.glowIntensity - 0.03, 0);
              }
              
              // Apply glow to rangoli material
              if (obj.material) {
                obj.material.opacity = 1 + obj.userData.glowIntensity * 0.3;
              }
            }
            
            // Animate ripple effect
            if (obj.userData.ripple && obj.userData.ripple.visible) {
              const rippleAge = (now - obj.userData.ripple.userData.rippleStart) / 1000;
              if (rippleAge < 1.5) {
                const scale = 1 + rippleAge * 2;
                obj.userData.ripple.scale.set(scale, scale, 1);
                obj.userData.ripple.material.opacity = (1 - rippleAge / 1.5) * 0.6;
              } else {
                obj.userData.ripple.visible = false;
              }
            }
            
            // Animate flowing particles (throttled updates)
            if (obj.userData.particles && Math.random() > 0.5) {
              const particles = obj.userData.particles;
              const positions = particles.geometry.attributes.position.array;
              const speeds = particles.userData.speeds;
              const phases = particles.userData.phases;
              
              // Update fewer particles per frame for performance
              const updateCount = Math.floor(positions.length / 9);
              for (let i = 0; i < updateCount; i++) {
                const idx = Math.floor(Math.random() * (positions.length / 3));
                const i3 = idx * 3;
                const angle = time * speeds[idx] + phases[idx];
                const radius = 1.2 + Math.sin(time * 0.3 + idx * 0.1) * 0.5;
                positions[i3] = Math.cos(angle) * radius;
                positions[i3 + 1] = 0.15 + Math.sin(time + idx * 0.2) * 0.08;
                positions[i3 + 2] = Math.sin(angle) * radius;
              }
              particles.geometry.attributes.position.needsUpdate = true;
              particles.rotation.y = time * 0.08;
              
              // Boost particle glow when user is close
              particles.material.opacity = 0.6 + obj.userData.glowIntensity * 0.4;
            }
          }
          
          renderer.render(scene, camera);
        });

        window.addEventListener('resize', () => renderer.setSize(window.innerWidth, window.innerHeight));
        window.addEventListener('beforeunload', () => { try { session.end(); } catch {} });
      }
    })();
  </script>
</body>
</html>