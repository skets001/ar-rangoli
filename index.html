<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"
  />
  <title>AR Rangoli — Tap to Place</title>
  <meta name="theme-color" content="#0c0c0c" />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
  <style>
    :root {
      --bg: #0b0b0e;
      --fg: #f7f2ea;
      --accent: #e15a97;  /* rani pink */
      --accent-2: #ffb703;/* marigold */
      --muted: #9b9ba3;
      --btn-bg: #17171f;
      --btn-brd:#34343d;
    }
    html, body { margin:0; padding:0; height:100%; background:var(--bg); color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Arial;
    }
    canvas{ display:block; }

    /* Top bar */
    .topbar{position:fixed;top:0;left:0;right:0;display:flex;justify-content:space-between;align-items:center;
      padding:10px 12px; gap:10px; background:linear-gradient(180deg,rgba(12,12,14,.95) 0%, rgba(12,12,14,.4) 100%);
      backdrop-filter: blur(6px); z-index:5; pointer-events:none}
    .brand{pointer-events:auto;display:flex;align-items:center;gap:10px;font-weight:700;letter-spacing:.3px}
    .brand .dot{width:10px;height:10px;border-radius:50%;
      background:radial-gradient(circle at 30% 30%, #fff 0, #ffd166 40%, #f94144 100%);
      box-shadow:0 0 8px rgba(255,210,50,.9)}
    .badge{pointer-events:auto;border-radius:999px;border:1px solid #2c2c34;padding:6px 10px;font-size:12px;color:var(--muted)}

    /* Loader + enter gate */
    .loader{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(circle at 50% 40%, #141420, #0b0b0e 60%);z-index:10;color:var(--fg);text-align:center;padding:24px}
    .chakra{width:84px;height:84px;border-radius:50%;border:3px dashed #ffd166;animation:spin 2.2s linear infinite;box-shadow:0 0 0 2px rgba(255,255,255,.03) inset;position:relative;margin:auto}
    .chakra::after{content:"";position:absolute;inset:14px;border-radius:50%;border:2px dotted #e15a97;animation:spin 3.6s linear infinite reverse;filter:drop-shadow(0 0 12px rgba(225,90,151,.35))}
    @keyframes spin{to{transform:rotate(360deg)}}
    .loader p{margin-top:16px;font-size:14px;color:var(--muted)}
    .btn{pointer-events:auto;display:inline-block;margin-top:14px;padding:12px 16px;border-radius:12px;border:1px solid var(--btn-brd);background:var(--btn-bg);color:#fff;font-weight:600}
    .btn:active{transform:scale(.98)}
    .hint{margin-top:10px;font-size:12px;color:#9b9ba3}

    /* Center cue */
    .center-cue{position:fixed;inset:0;display:grid;place-items:center;z-index:4;pointer-events:none;transition:opacity .3s ease}
    .center-cue .card{pointer-events:auto;background:rgba(10,10,14,.75);backdrop-filter:blur(8px);
      border:1px solid rgba(255,255,255,.06);border-radius:16px;padding:12px 14px;text-align:center;
      max-width:280px;color:var(--fg);box-shadow:0 10px 30px rgba(0,0,0,.35);animation:pop .38s ease-out both}
    .center-cue h3{margin:0 0 4px;font-size:17px}
    .center-cue p{margin:0;font-size:13px;color:var(--muted)}
    @keyframes pop{from{transform:translateY(8px) scale(.98);opacity:0}to{transform:translateY(0) scale(1);opacity:1}}

    /* Bottom controls (dom-overlay UI) */
    .controlbar{position:fixed;left:0;right:0;bottom:0;padding:10px 12px 16px;display:flex;justify-content:center;gap:10px;
      background:linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(12,12,14,.85) 35%, rgba(12,12,14,1) 100%);
      pointer-events:none; z-index:6}
    .controlbar .control{pointer-events:auto;min-width:44px;height:44px;border-radius:12px;border:1px solid var(--btn-brd);
      background:var(--btn-bg); color:#fff;font-weight:700;display:flex;align-items:center;justify-content:center;padding:0 12px}
    .control:active{transform:scale(.98)}
    .control.wide{min-width:96px}
    .control .sub{font-weight:500;color:var(--muted);font-size:11px;margin-left:6px}

    .overlay{position:fixed;inset:0;pointer-events:none;display:grid;place-items:end center;padding:env(safe-area-inset-bottom)}
    .hud{width:100%;box-sizing:border-box;padding:6px 12px;display:flex;gap:10px;justify-content:center;align-items:center;pointer-events:none}
    .pill{pointer-events:auto;border:1px solid #262630;background:#13131a;color:var(--fg);border-radius:999px;padding:8px 12px;font-size:13px;opacity:.95;display:inline-flex;align-items:center;gap:8px;box-shadow:0 2px 10px rgba(0,0,0,.35)}
    .pill b{color:var(--accent-2)}

    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  </style>
</head>
<body>
  <!-- Top bar -->
  <div class="topbar" id="topbar">
    <div class="brand"><span class="dot"></span> AR Rangoli</div>
    <div class="badge" id="statusBadge">Ready</div>
  </div>

  <!-- Loader / Enter gate -->
  <div class="loader" id="loader" role="status" aria-live="polite">
    <div class="chakra" aria-hidden="true"></div>
    <p id="loaderText">Tap to start AR (needed for permission)</p>
    <button class="btn" id="enterBtn">Enter AR</button>
    <div class="hint">
      If you denied camera before: Chrome ⋮ → Site settings → Clear & reset.<br/>
      Must be HTTPS + Android Chrome with Google Play Services for AR.
    </div>
  </div>

  <!-- Center cue -->
  <div class="center-cue" id="centerCue">
    <div class="card">
      <h3>Move your phone</h3>
      <p>Detect a floor/wall & <b>tap</b> to place. Use controls to rotate/scale.</p>
    </div>
  </div>

  <!-- Dom-overlay control bar -->
  <div class="controlbar" id="controls" style="display:none">
    <button class="control" id="btnSmaller" title="Smaller">–</button>
    <button class="control" id="btnBigger"  title="Bigger">+</button>
    <button class="control" id="btnRotL"    title="Rotate Left">↺</button>
    <button class="control" id="btnRotR"    title="Rotate Right">↻</button>
    <button class="control wide" id="btnPattern" title="Change Pattern">🎨 <span class="sub">Style</span></button>
    <button class="control" id="btnReset"   title="Reset">⟲</button>
  </div>

  <!-- Tip pill -->
  <div class="overlay">
    <div class="hud">
      <div class="pill">Tip: Use a <b>bright floor</b> for best tracking</div>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>

  <script>
    /* ========= Reticle ========= */
    function createReticle() {
      const geo = new THREE.RingGeometry(0.09, 0.1, 64);
      geo.rotateX(-Math.PI / 2);
      const mat = new THREE.MeshBasicMaterial({ color: 0xffb703, transparent: true, opacity: 0.95 });
      const ring = new THREE.Mesh(geo, mat);
      const geo2 = new THREE.RingGeometry(0.055, 0.07, 32);
      geo2.rotateX(-Math.PI / 2);
      const mat2 = new THREE.MeshBasicMaterial({ color: 0xe15a97, transparent: true, opacity: 0.95 });
      const ring2 = new THREE.Mesh(geo2, mat2);
      const group = new THREE.Group(); group.add(ring, ring2);
      group.tick = (t) => { const s = 1 + Math.sin(t * 2.2) * 0.03; group.scale.set(s, s, s); };
      group.visible = false; return group;
    }

    /* ========= Procedural Rangoli (3 styles) ========= */
    function drawRangoliTexture(size = 1024, style = 0) {
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d'); ctx.clearRect(0,0,size,size);
      const cx = size/2, cy = size/2, R = size*0.46;

      // helpers
      function petal(angle, r1, r2, w, colorA, colorB){
        ctx.save(); ctx.translate(cx,cy); ctx.rotate(angle);
        const grad = ctx.createLinearGradient(0,-r1,0,-r2);
        grad.addColorStop(0,colorA); grad.addColorStop(1,colorB);
        ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(0,-r1);
        ctx.bezierCurveTo(w,-r1*0.65, w,-r2*0.35, 0,-r2);
        ctx.bezierCurveTo(-w,-r2*0.35, -w,-r1*0.65, 0,-r1);
        ctx.closePath(); ctx.fill(); ctx.restore();
      }
      function dottedCircle(r,dots,color){
        for(let i=0;i<dots;i++){const a=(i/dots)*Math.PI*2; const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r;
          const g=ctx.createRadialGradient(x,y,0,x,y,size*0.02);
          g.addColorStop(0,color); g.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=g;
          ctx.beginPath(); ctx.arc(x,y,size*0.012,0,Math.PI*2); ctx.fill();
        }
      }

      // background glow
      const radial = ctx.createRadialGradient(cx,cy,R*.05,cx,cy,R*1.02);
      radial.addColorStop(0,'rgba(255,255,255,0.06)');
      radial.addColorStop(0.65,'rgba(255,210,100,0.04)');
      radial.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle = radial; ctx.beginPath(); ctx.arc(cx,cy,R*1.05,0,Math.PI*2); ctx.fill();

      const petals = 12;

      if (style === 0) {
        // Classic lotus + marigold
        for(let i=0;i<petals;i++){ petal((i/petals)*Math.PI*2, R*.92, R*.55, R*.25, '#ff6b6b', '#f94144'); }
        for(let i=0;i<petals;i++){ petal((i/petals)*Math.PI*2+Math.PI/petals, R*.6, R*.34, R*.16, '#ffd166', '#ffb703'); }
        for(let i=0;i<petals;i++){ petal((i/petals)*Math.PI*2, R*.36, R*.15, R*.11, '#7bd389', '#06d6a0'); }
        ctx.strokeStyle='rgba(255,255,255,0.82)'; ctx.lineWidth=size*0.006;
        [0.52,0.38,0.26,0.18,0.12].forEach(mult=>{ctx.beginPath();ctx.arc(cx,cy,R*mult,0,Math.PI*2);ctx.stroke();});
        dottedCircle(R*0.48,36,'#ffb703'); dottedCircle(R*0.33,24,'#e15a97'); dottedCircle(R*0.22,16,'#90e0ef');
        const g2 = ctx.createRadialGradient(cx,cy,0,cx,cy,R*0.16);
        g2.addColorStop(0,'#fff'); g2.addColorStop(0.4,'#ffd166'); g2.addColorStop(1,'#e15a97');
        ctx.fillStyle=g2; ctx.beginPath(); ctx.arc(cx,cy,R*0.16,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#2d0e36'; ctx.beginPath(); ctx.arc(cx,cy,R*0.04,0,Math.PI*2); ctx.fill();
      } else if (style === 1) {
        // Peacock hues + kolam grid hints
        for(let i=0;i<petals;i++){ petal((i/petals)*Math.PI*2, R*.95, R*.58, R*.28, '#6fffe9', '#3a86ff'); }
        for(let i=0;i<petals;i++){ petal((i/petals)*Math.PI*2+Math.PI/petals, R*.62, R*.36, R*.15, '#ffe66d', '#ff9f1c'); }
        ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=size*0.0055;
        [0.5,0.42,0.34,0.26,0.18,0.12].forEach(mult=>{ctx.beginPath();ctx.arc(cx,cy,R*mult,0,Math.PI*2);ctx.stroke();});
        dottedCircle(R*0.47,48,'#ff9f1c'); dottedCircle(R*0.31,24,'#8338ec');
        // simple kolam-like diamonds
        ctx.strokeStyle='rgba(255,255,255,0.75)'; ctx.lineWidth=size*0.0045;
        for(let k=0;k<8;k++){
          const a=(k/8)*Math.PI*2;
          ctx.save(); ctx.translate(cx,cy); ctx.rotate(a);
          ctx.beginPath(); ctx.moveTo(0,-R*0.22); ctx.lineTo(R*0.12,0); ctx.lineTo(0,R*0.22); ctx.lineTo(-R*0.12,0); ctx.closePath(); ctx.stroke();
          ctx.restore();
        }
      } else {
        // Deep magenta / teal + heavier dots
        for(let i=0;i<petals;i++){ petal((i/petals)*Math.PI*2, R*.9, R*.52, R*.24, '#ff4d6d', '#c9184a'); }
        for(let i=0;i<petals;i++){ petal((i/petals)*Math.PI*2+Math.PI/petals, R*.57, R*.32, R*.14, '#80ed99', '#06d6a0'); }
        ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.lineWidth=size*0.006;
        [0.5,0.37,0.25,0.17,0.11].forEach(mult=>{ctx.beginPath();ctx.arc(cx,cy,R*mult,0,Math.PI*2);ctx.stroke();});
        dottedCircle(R*0.49,40,'#ffd166'); dottedCircle(R*0.29,20,'#06d6a0');
        const g3 = ctx.createRadialGradient(cx,cy,0,cx,cy,R*0.18);
        g3.addColorStop(0,'#ffffff'); g3.addColorStop(0.5,'#c9184a'); g3.addColorStop(1,'#4cc9f0');
        ctx.fillStyle=g3; ctx.beginPath(); ctx.arc(cx,cy,R*0.18,0,Math.PI*2); ctx.fill();
      }

      return c;
    }

    /* ========= App ========= */
    (function init() {
      const loader = document.getElementById('loader');
      const loaderText = document.getElementById('loaderText');
      const enterBtn = document.getElementById('enterBtn');
      const centerCue = document.getElementById('centerCue');
      const statusBadge = document.getElementById('statusBadge');
      const controls = document.getElementById('controls');

      // Control buttons
      const btnSmaller = document.getElementById('btnSmaller');
      const btnBigger  = document.getElementById('btnBigger');
      const btnRotL    = document.getElementById('btnRotL');
      const btnRotR    = document.getElementById('btnRotR');
      const btnPattern = document.getElementById('btnPattern');
      const btnReset   = document.getElementById('btnReset');

      if (!('xr' in navigator)) {
        loaderText.innerHTML = "WebXR not available. Use <b>Android Chrome</b> over HTTPS.";
        enterBtn.style.display = "none";
        return;
      }

      enterBtn.addEventListener('click', async () => {
        enterBtn.disabled = true;
        loaderText.textContent = "Starting AR…";
        try {
          const ok = await navigator.xr.isSessionSupported('immersive-ar').catch(() => false);
          if (!ok) {
            loaderText.innerHTML = "Your device/browser doesn’t support WebXR AR. Try Android Chrome.";
            enterBtn.disabled = false;
            return;
          }
          await startAR(); // user activation scope
        } catch (err) {
          loaderText.innerHTML = "Camera permission denied or AR failed.<br/><small>" + String(err && err.message || err) + "</small>";
          enterBtn.disabled = false;
        }
      });

      async function startAR() {
        // THREE scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera();
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // lights
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

        // reticle
        const reticle = createReticle(); scene.add(reticle);

        // rangoli texture variants
        let styleIndex = 0;
        statusBadge.textContent = "Drawing rangoli…";
        const baseCanvas = drawRangoliTexture(1024, styleIndex);
        const baseTex = new THREE.CanvasTexture(baseCanvas);
        baseTex.anisotropy = 8; baseTex.encoding = THREE.sRGBEncoding;

        function createMaterial() {
          const c = drawRangoliTexture(1024, styleIndex);
          const t = new THREE.CanvasTexture(c);
          t.anisotropy = 8; t.encoding = THREE.sRGBEncoding;
          return new THREE.MeshBasicMaterial({ map: t, transparent: true });
        }

        function createRangoliMesh() {
          const sizeMeters = 0.9; // a bit bigger for wow
          const geo = new THREE.PlaneGeometry(sizeMeters, sizeMeters);
          const mat = createMaterial();
          const mesh = new THREE.Mesh(geo, mat);
          mesh.rotation.x = -Math.PI / 2;
          mesh.renderOrder = 1;

          // drop shadow halo
          const sh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.18 }));
          sh.position.y = -0.001; sh.scale.set(1.04,1.04,1.04);
          mesh.add(sh);

          // entrance anim
          mesh.scale.set(0.58,0.58,0.58);
          mesh.userData.spawnT = performance.now();
          mesh.userData.animIn = true;
          mesh.userData.isRangoli = true;

          return mesh;
        }

        // XR session with DOM overlay for on-screen buttons
        const sessionInit = {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay', 'light-estimation'],
          domOverlay: { root: document.body }
        };
        const session = await navigator.xr.requestSession('immersive-ar', sessionInit);

        statusBadge.textContent = "Point phone to scan…";
        renderer.xr.setReferenceSpaceType('local');
        await renderer.xr.setSession(session);

        const referenceSpace = await session.requestReferenceSpace('local');
        const viewerSpace = await session.requestReferenceSpace('viewer');
        const hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

        // Manage placements & “selected” item
        const placed = [];
        let selected = null;

        function selectLast() {
          selected = placed[placed.length - 1] || null;
          // subtle highlight (scale pulse once)
          if (selected) {
            selected.userData.pulseT = performance.now();
          }
        }

        session.addEventListener('select', () => {
          if (!reticle.visible) return;
          const mesh = createRangoliMesh();
          mesh.position.setFromMatrixPosition(reticle.matrix);

          // Align to surface
          const rot = new THREE.Quaternion().setFromRotationMatrix(reticle.matrix);
          mesh.quaternion.copy(rot);
          const up = new THREE.Vector3(0,1,0).applyQuaternion(mesh.quaternion);
          if (Math.abs(up.y) < 0.4) {
            const normal = new THREE.Vector3(0,0,-1).applyQuaternion(rot).normalize();
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), normal);
            mesh.quaternion.copy(targetQuat);
            mesh.position.addScaledVector(normal, 0.002);
          } else {
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.y += 0.001;
          }

          scene.add(mesh);
          placed.push(mesh);
          selectLast();
          centerCue.style.opacity = "0"; setTimeout(()=>centerCue.style.display="none", 400);
        });

        // Controls
        function nudgeScale(delta){
          if (!selected) return;
          const s = selected.scale.x;
          const ns = THREE.MathUtils.clamp(s + delta, 0.3, 2.5);
          selected.scale.set(ns, ns, ns);
        }
        function nudgeRotate(deg){
          if (!selected) return;
          // rotate around Z for walls / Y for floors to feel natural
          const up = new THREE.Vector3(0,1,0).applyQuaternion(selected.quaternion);
          if (Math.abs(up.y) < 0.4) {
            selected.rotateZ(THREE.MathUtils.degToRad(deg));
          } else {
            selected.rotateY(THREE.MathUtils.degToRad(deg));
          }
        }
        function cyclePattern(){
          styleIndex = (styleIndex + 1) % 3;
          // Update material on the selected or last placed; if none, change the base for next placements
          const target = selected || placed[placed.length - 1];
          if (target) {
            const newMat = createMaterial();
            target.material.dispose();
            target.material = newMat;
          } else {
            // just updates the pre-drawn base (effectively next placement style)
            baseTex.needsUpdate = true;
          }
        }
        function resetAll(){
          for (const m of placed) {
            m.traverse(o => {
              if (o.material && o.material.map) o.material.map.dispose();
              if (o.material) o.material.dispose();
              if (o.geometry) o.geometry.dispose();
            });
            scene.remove(m);
          }
          placed.length = 0;
          selected = null;
          centerCue.style.display = "grid"; centerCue.style.opacity = "1";
        }

        // Wire buttons
        controls.style.display = "flex";
        btnSmaller.onclick = () => nudgeScale(-0.08);
        btnBigger.onclick  = () => nudgeScale(+0.08);
        btnRotL.onclick    = () => nudgeRotate(-8);
        btnRotR.onclick    = () => nudgeRotate(+8);
        btnPattern.onclick = () => cyclePattern();
        btnReset.onclick   = () => resetAll();

        // Entered AR → hide loader
        loader.style.opacity = "0"; setTimeout(()=>loader.remove(), 180);

        // Animation loop
        renderer.setAnimationLoop((t, frame) => {
          if (reticle.tick) reticle.tick(t/1000);
          if (frame) {
            const hits = frame.getHitTestResults(hitTestSource);
            if (hits.length) {
              const pose = hits[0].getPose(referenceSpace);
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            } else {
              reticle.visible = false;
            }
          }

          // entrance + select pulse
          const now = performance.now();
          for (const obj of placed) {
            if (obj.userData.animIn) {
              const dt = Math.min((now - obj.userData.spawnT) / 450, 1);
              const s = 0.58 + (1 - 0.58) * (1 - Math.pow(1 - dt, 3));
              obj.scale.set(s,s,s);
              if (dt >= 1) obj.userData.animIn = false;
            }
            if (obj === selected && obj.userData.pulseT) {
              const tt = (now - obj.userData.pulseT) / 400;
              if (tt <= 1) {
                const extra = (1 - Math.pow(1-tt, 3)) * 0.05;
                obj.scale.set(obj.scale.x + extra, obj.scale.y + extra, obj.scale.z + extra);
              } else {
                delete obj.userData.pulseT;
              }
            }
          }

          renderer.render(scene, camera);
        });

        // Resize & cleanup
        window.addEventListener('resize', () => renderer.setSize(window.innerWidth, window.innerHeight));
        window.addEventListener('beforeunload', () => { try { session.end(); } catch {} });
      }
    })();
  </script>
</body>
</html>
